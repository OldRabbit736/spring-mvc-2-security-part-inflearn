개요
- filter
    - servlet 이 제공
- interceptor
    - spring 이 제공
- 둘 다 비슷한 역할을 함
- 로그인한 사용자와 하지 않은 사용자를 구별하여 페이지를 다르게 보여야 한다.
- 그렇다면 그 로직을 모든 컨트롤러에 심어야 하는걸까?
  이 기능은 똑같은 기능이며 하나의 함수로 해결할 수 있다고 해도, 모든 컨트롤러에 함수를 호출해야 한다.
- 이렇게 애플리케이션 여러 로직에서 공통으로 관심이 있는 부분을 공통 관심사(cross-cutting concern)라고 한다.
  여기서는 인증이 공통 관심사이다.
- 공통 관심사는 스프링 AOP 로도 해결할 수 있지만, 웹과 관련된 공통 관심사는 서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다.
- 웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데,
  스프링 필터나 스프링 인터셉터는 HttpServletRequest 를 제공한다. 그 외에도 많은 기능을 제공한다.
  반면, AOP는 제공되는 정보나 기능이 상대적으로 단순한 편이다.

servlet filter
- 서블릿이 지원하는 수문장이다.
- 필터 흐름
    - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러
    - 필터를 적용하면 필터가 서블릿이 호출되기 전 호출된다.
      만약 모든 고객의 요청 로그를 남기는 요구사항이 있다면, 해당 로직을 필터에서 실행시키면 된다.
    - 필터는 특정 URL 패턴에 적용할 수 있다.
    - 여기서 서블릿은 스프링의 경우에는 DispatcherServlet 이다.
- 필터 제한
    - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 // 로그인 사용자
    - HTTP 요청 -> WAS -> 필터 (적절하지 않은 요청이라 판단, 서블릿 호출 X) // 비 로그인 사용자
    - 필터에서 적절하지 않은 요청이라 판단하면 요청을 끝낼 수 있다. 그래서 로그인 여부를 체크하는 로직을 적용하기에 좋다.
- 필터 체인
    - HTTP 요청 -> WAS -> 필터1 -> 필터2 -> 필터3 -> 서블릿
    - 필터는 체인으로 구성되는데, 중간에 필터를 자유롭게 추가할 수 있다.
      예를들어 로그를 남기는 필터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다.
- 필터 인터페이스
    - Filter interface --> init(), doFilter(), destroy() 세 가지 메서드 존재
    - 필터 인터페이스를 구현하고 등록하면, 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고, 관리한다.
        - init(): 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다.
        - doFilter(): 고객의 요청이 올 때마다 해당 메서드가 호출된다. 필터의 로직이 구현된 곳이다.
        - destroy(): 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.
- 필터 등록
    - FilterRegistrationBean 을 이용해 등록할 수 있다다.
    - @ServletComponentScan, @WebFilter 로 필터 등록이 가능하지만
      필터 순서 조절이 안된다. 따라서 FilterRegistrationBean 을 이용하자.
- 참고
    - 실무에서 HTTP 요청 시 같은 요청의 로그에 모두 같은 식별자를 자동으로 남길 때 logback mdc 라는 것을 사용한다고 한다.
